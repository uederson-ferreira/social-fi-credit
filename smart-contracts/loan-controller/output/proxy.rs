// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LoanControllerProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LoanControllerProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LoanControllerProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LoanControllerProxyMethods { wrapped_tx: tx }
    }
}

pub struct LoanControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LoanControllerProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        reputation_score_address: Arg0,
        min_required_score: Arg1,
        interest_rate_base: Arg2,
        base_loan_amount: Arg3,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&reputation_score_address)
            .argument(&min_required_score)
            .argument(&interest_rate_base)
            .argument(&base_loan_amount)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LoanControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn withdraw_funds<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdrawFunds")
            .argument(&amount)
            .original_result()
    }

    pub fn set_loan_terms<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        standard: Arg0,
        extended: Arg1,
        short: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLoanTerms")
            .argument(&standard)
            .argument(&extended)
            .argument(&short)
            .original_result()
    }

    pub fn request_loan<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<LoanTerm>,
    >(
        self,
        amount: Arg0,
        term: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("requestLoan")
            .argument(&amount)
            .argument(&term)
            .original_result()
    }

    pub fn repay_loan<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repayLoan")
            .argument(&loan_id)
            .original_result()
    }

    pub fn extend_loan_deadline<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
        extra_days: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("extendLoanDeadline")
            .argument(&loan_id)
            .argument(&extra_days)
            .original_result()
    }

    pub fn provide_collateral<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("provideCollateral")
            .argument(&loan_id)
            .original_result()
    }

    pub fn withdraw_collateral<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawCollateral")
            .argument(&loan_id)
            .original_result()
    }

    pub fn mark_loan_defaulted<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("markLoanDefaulted")
            .argument(&loan_id)
            .original_result()
    }

    pub fn forfeit_collateral<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("forfeitCollateral")
            .argument(&loan_id)
            .original_result()
    }

    pub fn provide_collateral_for_new_loan(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("provideCollateralForNewLoan")
            .original_result()
    }

    pub fn request_loan_with_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("requestLoanWithCollateral")
            .original_result()
    }

    pub fn cancel_loan_request(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelLoanRequest")
            .original_result()
    }

    /// Leiloar garantia de um empréstimo inadimplente 
    pub fn liquidate_collateral_via_auction<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("liquidateCollateralViaAuction")
            .argument(&loan_id)
            .original_result()
    }

    pub fn partial_repay_loan<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("partialRepayLoan")
            .argument(&loan_id)
            .original_result()
    }

    pub fn add_investor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        investor: Arg0,
        shares: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_investor")
            .argument(&investor)
            .argument(&shares)
            .original_result()
    }

    /// Distribui os juros acumulados entre os investidores, conforme suas participações, 
    /// e então zera o total_interest_earned. 
    pub fn distribute_profits(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("distributeProfits")
            .original_result()
    }

    /// Remove um investidor e ajusta o total de participações 
    pub fn remove_investor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        investor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeInvestor")
            .argument(&investor)
            .original_result()
    }

    /// Modo de emergência: sacar todo o saldo 
    pub fn emergency_withdraw(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("emergencyWithdraw")
            .original_result()
    }

    /// Lista negra: impede que um usuário solicite empréstimos 
    pub fn add_to_blacklist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addToBlacklist")
            .argument(&user)
            .original_result()
    }

    /// Consulta se um usuário está na blacklist 
    pub fn is_blacklisted<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBlacklisted")
            .argument(&user)
            .original_result()
    }

    /// Remove um usuário da blacklist, permitindo que ele solicite empréstimos de novo 
    pub fn remove_from_blacklist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeFromBlacklist")
            .argument(&user)
            .original_result()
    }

    pub fn set_max_loans_per_user<
        Arg0: ProxyArg<u64>,
    >(
        self,
        max: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxLoansPerUser")
            .argument(&max)
            .original_result()
    }

    pub fn set_min_collateral_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinCollateralAmount")
            .argument(&amount)
            .original_result()
    }

    pub fn set_min_interest_rate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        rate: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_min_interest_rate")
            .argument(&rate)
            .original_result()
    }

    pub fn set_max_interest_rate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        rate: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_max_interest_rate")
            .argument(&rate)
            .original_result()
    }

    pub fn get_min_interest_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinInterestRate")
            .original_result()
    }

    pub fn get_max_interest_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxInterestRate")
            .original_result()
    }

    pub fn set_mock_timestamp<
        Arg0: ProxyArg<u64>,
    >(
        self,
        timestamp: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mock_timestamp")
            .argument(&timestamp)
            .original_result()
    }

    pub fn get_block_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_timestamp")
            .original_result()
    }

    pub fn set_max_active_loans<
        Arg0: ProxyArg<u64>,
    >(
        self,
        max_loans: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_max_active_loans")
            .argument(&max_loans)
            .original_result()
    }

    pub fn get_max_active_loans(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxActiveLoans")
            .original_result()
    }

    pub fn get_repaid_loans_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRepaidLoansCount")
            .original_result()
    }

    pub fn request_loan_sync<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        amount: Arg0,
        duration_days: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("requestLoanSync")
            .argument(&amount)
            .argument(&duration_days)
            .original_result()
    }

    pub fn mark_expired_loans(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mark_expired_loans")
            .original_result()
    }

    pub fn set_extension_fee_percent<
        Arg0: ProxyArg<u64>,
    >(
        self,
        fee_percent: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setExtensionFeePercent")
            .argument(&fee_percent)
            .original_result()
    }

    pub fn get_extension_fee_percent(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExtensionFeePercent")
            .original_result()
    }

    pub fn set_late_fee_daily_rate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        rate: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLateFeeDailyRate")
            .argument(&rate)
            .original_result()
    }

    pub fn get_late_fee_daily_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLateFeeDailyRate")
            .original_result()
    }

    pub fn set_collateral_ratio<
        Arg0: ProxyArg<u64>,
    >(
        self,
        ratio: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralRatio")
            .argument(&ratio)
            .original_result()
    }

    pub fn set_liquidation_discount<
        Arg0: ProxyArg<u64>,
    >(
        self,
        discount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationDiscount")
            .argument(&discount)
            .original_result()
    }

    pub fn get_collateral_ratio(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralRatio")
            .original_result()
    }

    pub fn get_liquidation_discount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationDiscount")
            .original_result()
    }

    pub fn get_investor_shares<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        investor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInvestorShares")
            .argument(&investor)
            .original_result()
    }

    pub fn get_total_investor_shares(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalInvestorShares")
            .original_result()
    }

    pub fn set_standard_loan_term_days<
        Arg0: ProxyArg<u64>,
    >(
        self,
        days: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_standard_loan_term_days")
            .argument(&days)
            .original_result()
    }

    pub fn set_extended_loan_term_days<
        Arg0: ProxyArg<u64>,
    >(
        self,
        days: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_extended_loan_term_days")
            .argument(&days)
            .original_result()
    }

    pub fn set_max_loan_term_days<
        Arg0: ProxyArg<u64>,
    >(
        self,
        days: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_max_loan_term_days")
            .argument(&days)
            .original_result()
    }

    pub fn reputation_check_callback<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        user_address: Arg0,
        score: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reputation_check_callback")
            .argument(&user_address)
            .argument(&score)
            .original_result()
    }

    pub fn get_standard_loan_term_days(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStandardLoanTermDays")
            .original_result()
    }

    pub fn get_extended_loan_term_days(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExtendedLoanTermDays")
            .original_result()
    }

    pub fn get_max_loan_term_days(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxLoanTermDays")
            .original_result()
    }

    pub fn set_interest_rate_base<
        Arg0: ProxyArg<u64>,
    >(
        self,
        rate: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_interest_rate_base")
            .argument(&rate)
            .original_result()
    }

    pub fn set_extended_term_rate_multiplier<
        Arg0: ProxyArg<u64>,
    >(
        self,
        multiplier: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_extended_term_rate_multiplier")
            .argument(&multiplier)
            .original_result()
    }

    pub fn set_max_term_rate_multiplier<
        Arg0: ProxyArg<u64>,
    >(
        self,
        multiplier: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_max_term_rate_multiplier")
            .argument(&multiplier)
            .original_result()
    }

    pub fn set_min_required_score<
        Arg0: ProxyArg<u64>,
    >(
        self,
        score: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_min_required_score")
            .argument(&score)
            .original_result()
    }

    pub fn initiate_contract_destruction(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("initiateContractDestruction")
            .original_result()
    }

    pub fn execute_contract_destruction(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("executeContractDestruction")
            .original_result()
    }

    pub fn initiate_contract_destruction_v2(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("initiateContractDestructionV2")
            .original_result()
    }

    pub fn pause_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseContract")
            .original_result()
    }

    pub fn unpause_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpauseContract")
            .original_result()
    }

    pub fn confirm_contract_destruction_v2(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("confirmContractDestructionV2")
            .original_result()
    }

    pub fn cancel_contract_destruction_v2(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelContractDestructionV2")
            .original_result()
    }

    pub fn request_loan_with_term<
        Arg0: ProxyArg<LoanTerm>,
    >(
        self,
        term: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("requestLoanWithTerm")
            .argument(&term)
            .original_result()
    }

    pub fn get_min_required_score(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinRequiredScore")
            .original_result()
    }

    pub fn get_interest_rate_base(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInterestRateBase")
            .original_result()
    }

    pub fn get_extended_term_rate_multiplier(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExtendedTermRateMultiplier")
            .original_result()
    }

    pub fn get_max_term_rate_multiplier(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxTermRateMultiplier")
            .original_result()
    }

    pub fn calculate_due_date_safely<
        Arg0: ProxyArg<u64>,
    >(
        self,
        term_in_seconds: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateDueDateSafely")
            .argument(&term_in_seconds)
            .original_result()
    }

    pub fn calculate_loan_amount_with_limits<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateLoanAmountWithLimits")
            .argument(&base_amount)
            .original_result()
    }

    pub fn get_active_loans_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getActiveLoansCount")
            .original_result()
    }

    pub fn set_operation_timelock<
        Arg0: ProxyArg<u64>,
    >(
        self,
        timelock: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_operation_timelock")
            .argument(&timelock)
            .original_result()
    }

    pub fn get_operation_timelock(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOperationTimelock")
            .original_result()
    }

    pub fn get_loan_details<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<Loan<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLoanDetails")
            .argument(&loan_id)
            .original_result()
    }

    pub fn calculate_due_date<
        Arg0: ProxyArg<LoanTerm>,
    >(
        self,
        term: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateDueDate")
            .argument(&term)
            .original_result()
    }

    pub fn get_loan_term_days<
        Arg0: ProxyArg<LoanTerm>,
    >(
        self,
        term: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLoanTermDays")
            .argument(&term)
            .original_result()
    }

    pub fn get_interest_rate_for_term<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<LoanTerm>,
    >(
        self,
        base_rate: Arg0,
        term: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateInterestRateForTerm")
            .argument(&base_rate)
            .argument(&term)
            .original_result()
    }

    pub fn get_overdue_loans_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOverdueLoansCount")
            .original_result()
    }

    pub fn get_total_loan_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalLoanAmount")
            .original_result()
    }

    pub fn get_total_repayment_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalRepaymentAmount")
            .original_result()
    }

    pub fn is_paused(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .original_result()
    }

    pub fn calculate_liquidation_value<
        Arg0: ProxyArg<u64>,
    >(
        self,
        loan_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateLiquidationValue")
            .argument(&loan_id)
            .original_result()
    }

    /// Add these view methods inside the `#[multiversx_sc::contract] pub trait LoanController`: 
    /// Returns all loan IDs associated with a user 
    pub fn get_user_loan_history<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Vec<u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserLoanHistory")
            .argument(&user)
            .original_result()
    }

    /// Returns only the active loan IDs for a user 
    pub fn get_user_active_loans<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Vec<u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserActiveLoans")
            .argument(&user)
            .original_result()
    }

    /// Returns only the repaid loan IDs for a user 
    pub fn get_user_repaid_loans<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Vec<u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserRepaidLoans")
            .argument(&user)
            .original_result()
    }
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, PartialEq, Debug, Clone, Copy, ManagedVecItem)]
pub enum LoanTerm {
    Standard,
    Extended,
    Short,
    Maximum,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct Loan<Api>
where
    Api: ManagedTypeApi,
{
    pub borrower: ManagedAddress<Api>,
    pub amount: BigUint<Api>,
    pub repayment_amount: BigUint<Api>,
    pub interest_rate: u64,
    pub creation_timestamp: u64,
    pub due_timestamp: u64,
    pub status: LoanStatus,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, PartialEq, Debug, Clone, ManagedVecItem)]
pub enum LoanStatus {
    Active,
    Repaid,
    Defaulted,
    Liquidated,
}
