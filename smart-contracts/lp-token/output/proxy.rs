// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LpTokenProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LpTokenProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LpTokenProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LpTokenProxyMethods { wrapped_tx: tx }
    }
}

pub struct LpTokenProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LpTokenProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Função de inicialização que é chamada uma única vez quando o contrato é deployado 
    /// @param initial_supply: Quantidade inicial de tokens a ser criada 
    /// @param token_name: Nome completo do token (ex: "Bitcoin") 
    /// @param token_ticker: Símbolo/código do token (ex: "BTC") 
    /// @param token_decimals: Número de casas decimais do token 
    pub fn init<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<u8>,
    >(
        self,
        initial_supply: Arg0,
        token_name: Arg1,
        token_ticker: Arg2,
        token_decimals: Arg3,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&initial_supply)
            .argument(&token_name)
            .argument(&token_ticker)
            .argument(&token_decimals)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LpTokenProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Retorna o nome completo do token 
    pub fn get_name(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getName")
            .original_result()
    }

    /// Retorna o símbolo/ticker do token 
    pub fn get_ticker(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTicker")
            .original_result()
    }

    /// Retorna o número de casas decimais do token 
    pub fn get_decimals(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDecimals")
            .original_result()
    }

    /// Retorna o suprimento total de tokens em circulação 
    pub fn total_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("totalSupply")
            .original_result()
    }

    /// Retorna o saldo de tokens de um determinado endereço 
    /// @param address: Endereço a consultar o saldo 
    pub fn balance_of<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("balanceOf")
            .argument(&address)
            .original_result()
    }

    /// Transfere tokens do remetente (caller) para outro endereço. 
    ///  
    /// # Parâmetros 
    /// - `to`: Endereço de destino que receberá os tokens. 
    /// - `amount`: Quantidade de tokens a transferir. 
    ///  
    /// # Regras 
    /// - A operação é bloqueada se o contrato estiver pausado. 
    /// - A transferência considera a taxa de transação (se configurada). 
    pub fn transfer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        to: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("transfer")
            .argument(&to)
            .argument(&amount)
            .original_result()
    }

    /// Retorna quanto um spender está autorizado a gastar em nome de um owner 
    /// @param owner: Dono dos tokens 
    /// @param spender: Endereço autorizado a gastar 
    pub fn allowance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        owner: Arg0,
        spender: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("allowance")
            .argument(&owner)
            .argument(&spender)
            .original_result()
    }

    /// Permite que um endereço autorizado transfira tokens em nome de outro 
    /// @param from: Endereço de origem dos tokens 
    /// @param to: Endereço de destino para receber os tokens 
    /// @param amount: Quantidade de tokens a transferir 
    pub fn transfer_from<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        from: Arg0,
        to: Arg1,
        amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("transferFrom")
            .argument(&from)
            .argument(&to)
            .argument(&amount)
            .original_result()
    }

    /// Cria novos tokens e os atribui a um endereço (somente owner) 
    /// @param to: Endereço que receberá os novos tokens 
    /// @param amount: Quantidade de tokens a criar 
    pub fn mint_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        to: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mint")
            .argument(&to)
            .argument(&amount)
            .original_result()
    }

    /// Destrói tokens de um endereço específico (somente owner) 
    /// @param address: Endereço de onde os tokens serão destruídos 
    /// @param amount: Quantidade de tokens a destruir 
    pub fn burn_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        address: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("burn")
            .argument(&address)
            .argument(&amount)
            .original_result()
    }

    /// Permite que um usuário destrua seus próprios tokens 
    /// @param amount: Quantidade de tokens a destruir 
    pub fn burn_own<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("burnOwn")
            .argument(&amount)
            .original_result()
    }

    /// Pausa todas as operações do contrato (somente owner) 
    /// Útil em caso de emergência ou manutenção 
    pub fn pause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    /// Despausa o contrato, permitindo que as operações voltem ao normal (somente owner) 
    pub fn unpause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }

    /// Verifica se o contrato está pausado 
    pub fn is_paused(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .original_result()
    }

    /// Define a porcentagem da taxa cobrada em transferências (somente owner) 
    /// @param fee_percentage: Valor da taxa em basis points (1% = 100, 0.5% = 50) 
    pub fn set_fee_percentage<
        Arg0: ProxyArg<u64>,
    >(
        self,
        fee_percentage: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setFeePercentage")
            .argument(&fee_percentage)
            .original_result()
    }

    /// Retorna a porcentagem atual da taxa em basis points 
    pub fn get_fee_percentage(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFeePercentage")
            .original_result()
    }

    pub fn approve<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        spender: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("approve")
            .argument(&spender)
            .argument(&amount)
            .original_result()
    }

    /// Permite que qualquer usuário receba tokens gratuitos (limitado a uma vez por endereço) 
    /// Função demonstrativa - útil para faucets ou airdrops 
    pub fn public_mint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("publicMint")
            .original_result()
    }
}
